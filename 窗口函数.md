### 用于排名
row_number() - 同薪不同名，相当于行号，例如3000、2000、2000、1000排名后为1、2、3、4

rank() - 同薪同名，有跳级，例如3000、2000、2000、1000排名后为1、2、2、4

dense_rank() - 同薪同名，无跳级，例如3000、2000、2000、1000排名后为1、2、2、3

ntile() - 分桶排名，即首先按桶的个数分出第一二三桶，然后各桶内从1排名，实际不是很常用
显然，本题是要用第三个函数。

#### 另外这三个函数必须要要与其搭档over()配套使用，over()中的参数常见的有两个，分别是
partition by - 按某字段切分
order by - 与常规order by用法一致，也区分ASC(默认)和DESC，因为排名总得有个依据

### 总结MySQL查询的一般性思路是：

能用==单表优先用单表==，即便是需要用group by、order by、limit等，==效率一般也比多表高==

不能用单表时优先用==连接==，连接是SQL中非常强大的用法，==小表驱动大表+建立合适索引+合理运用连接条件==，基本上连接可以解决绝大部分问题。但join级数不宜过多，毕竟是一个接近指数级增长的关联效果

能不用子查询、笛卡尔积尽量不用，虽然很多情况下MySQL优化器会将其优化成连接方式的执行过程，但效率仍然难以保证

==自定义变量==在复杂SQL实现中会很有用，例如LeetCode中困难级别的数据库题目很多都需要借助自定义变量实现

如果MySQL版本允许，某些带聚合功能的查询需求应用窗口函数是一个最优选择。除了经典的获取3种排名信息，还有聚合函数、向前向后取值、百分位等，具体可参考官方指南。以下是官方给出的几个窗口函数的介绍：
![[截屏2025-06-14 13.09.18.png]]

## [LEAD()](https://zhida.zhihu.com/search?content_id=206996536&content_type=Article&match_order=1&q=LEAD%28%29&zd_token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJ6aGlkYV9zZXJ2ZXIiLCJleHAiOjE3NDk5ODMxMDEsInEiOiJMRUFEKCkiLCJ6aGlkYV9zb3VyY2UiOiJlbnRpdHkiLCJjb250ZW50X2lkIjoyMDY5OTY1MzYsImNvbnRlbnRfdHlwZSI6IkFydGljbGUiLCJtYXRjaF9vcmRlciI6MSwiemRfdG9rZW4iOm51bGx9.HHzOgUDPo0tIM4XLMG0i1G5Y7IQHIWaDK7UR6fe_x9I&zhida_source=entity)函数

**lead()函数：**

查询当前行向下偏移n行后的结果

该函数有三个参数：第一个为待查询的列，第二个为向下偏移的位数，第三个参数为超出最下边界时的默认值。

```text
--查询向下偏移2位的年龄
SELECT user_id,
       user_age,
       lead(user_age, 2, 0) over(ORDER BY user_id)
  FROM user_info;
```

## LAG()函数

**lag()函数**：

查询当前行向上偏移n行后的结果（直观上是总体下移n行）

该函数有三个参数：第一个为待查询的列，第二个为向上偏移的行数，第三个为超出最上边界的默认值

```mysql
--查询向上偏移1位的年龄
SELECT user_id,
       user_age,
       lag(user_age, 1, 0) over(ORDER BY user_id) RESULT
FROM user_info;
```